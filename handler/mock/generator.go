// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/ONSdigital/dp-cantabular-csv-exporter/handler"
	"sync"
	"time"
)

// Ensure, that GeneratorMock does implement handler.Generator.
// If this is not the case, regenerate this file with moq.
var _ handler.Generator = &GeneratorMock{}

// GeneratorMock is a mock implementation of handler.Generator.
//
// 	func TestSomethingThatUsesGenerator(t *testing.T) {
//
// 		// make and configure a mocked handler.Generator
// 		mockedGenerator := &GeneratorMock{
// 			NewPSKFunc: func() ([]byte, error) {
// 				panic("mock out the NewPSK method")
// 			},
// 			TimestampFunc: func() time.Time {
// 				panic("mock out the Timestamp method")
// 			},
// 			UniqueIDFunc: func() (string, error) {
// 				panic("mock out the UniqueID method")
// 			},
// 		}
//
// 		// use mockedGenerator in code that requires handler.Generator
// 		// and then make assertions.
//
// 	}
type GeneratorMock struct {
	// NewPSKFunc mocks the NewPSK method.
	NewPSKFunc func() ([]byte, error)

	// TimestampFunc mocks the Timestamp method.
	TimestampFunc func() time.Time

	// UniqueIDFunc mocks the UniqueID method.
	UniqueIDFunc func() (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// NewPSK holds details about calls to the NewPSK method.
		NewPSK []struct {
		}
		// Timestamp holds details about calls to the Timestamp method.
		Timestamp []struct {
		}
		// UniqueID holds details about calls to the UniqueID method.
		UniqueID []struct {
		}
	}
	lockNewPSK    sync.RWMutex
	lockTimestamp sync.RWMutex
	lockUniqueID  sync.RWMutex
}

// NewPSK calls NewPSKFunc.
func (mock *GeneratorMock) NewPSK() ([]byte, error) {
	if mock.NewPSKFunc == nil {
		panic("GeneratorMock.NewPSKFunc: method is nil but Generator.NewPSK was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNewPSK.Lock()
	mock.calls.NewPSK = append(mock.calls.NewPSK, callInfo)
	mock.lockNewPSK.Unlock()
	return mock.NewPSKFunc()
}

// NewPSKCalls gets all the calls that were made to NewPSK.
// Check the length with:
//     len(mockedGenerator.NewPSKCalls())
func (mock *GeneratorMock) NewPSKCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNewPSK.RLock()
	calls = mock.calls.NewPSK
	mock.lockNewPSK.RUnlock()
	return calls
}

// Timestamp calls TimestampFunc.
func (mock *GeneratorMock) Timestamp() time.Time {
	if mock.TimestampFunc == nil {
		panic("GeneratorMock.TimestampFunc: method is nil but Generator.Timestamp was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTimestamp.Lock()
	mock.calls.Timestamp = append(mock.calls.Timestamp, callInfo)
	mock.lockTimestamp.Unlock()
	return mock.TimestampFunc()
}

// TimestampCalls gets all the calls that were made to Timestamp.
// Check the length with:
//     len(mockedGenerator.TimestampCalls())
func (mock *GeneratorMock) TimestampCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTimestamp.RLock()
	calls = mock.calls.Timestamp
	mock.lockTimestamp.RUnlock()
	return calls
}

// UniqueID calls UniqueIDFunc.
func (mock *GeneratorMock) UniqueID() (string, error) {
	if mock.UniqueIDFunc == nil {
		panic("GeneratorMock.UniqueIDFunc: method is nil but Generator.UniqueID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUniqueID.Lock()
	mock.calls.UniqueID = append(mock.calls.UniqueID, callInfo)
	mock.lockUniqueID.Unlock()
	return mock.UniqueIDFunc()
}

// UniqueIDCalls gets all the calls that were made to UniqueID.
// Check the length with:
//     len(mockedGenerator.UniqueIDCalls())
func (mock *GeneratorMock) UniqueIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUniqueID.RLock()
	calls = mock.calls.UniqueID
	mock.lockUniqueID.RUnlock()
	return calls
}
